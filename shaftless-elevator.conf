# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Shaftless Space Elevator v1.2

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    databank:
        class: databank
        select: manual
    screen:
        class: ScreenUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    button:
        class: ManualButtonUnit
        select: manual

handlers:
    unit:
        start:
            lua: |
                --system.print(unit.getData())
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(0)
                
                local build_helper=false --export: Selecting a checkbox will display the "Build Helper" in the interface during the flight.
                if build_helper==false then system.showHelper(0) else system.showHelper(1) end

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end
                
                -- instead of standard function
                function angle_between(vector1,vector2)
                    return math.acos(utils.clamp(vector1:dot(vector2) / (vector1:len() * vector2:len()),-1,1))
                end

                rollPID = pid.new(0.01, 0, 0.1)
                pitchPID = pid.new(0.01, 0, 0.1)
                yawPID = pid.new(0.01, 0, 0.1)
                
                local useDatabank = true --export: Use databank
                local updateDatabank = false --export: "true" - set existing varibles to the databank<br>"false" - get variables from the databank

                positions = {}
                positionNames = {}
                positionShow = {}
                positionExit = {}
                
                local function addPosition(newPositionName,newPosition,show,exitAllowed)
                    if newPositionName ~= "" then
                        table.insert(positions, newPosition)
                        table.insert(positionNames, newPositionName)
                        table.insert(positionShow, show)
                        if not show then exitAllowed = false end
                        table.insert(positionExit, exitAllowed)
                    end
                end

                local position_1_name = "Location 1" --export: Position 1 Name
                local position_1_show = true --export: Position 1 show in the list
                local position_1_exit = true --export: Position 1 exit when arrived
                local position_1_x = -53820 -- Initial World Position
                local position_1_y = 82100 -- Initial World Position
                local position_1_z = -47204 -- Initial World Position
                addPosition(position_1_name,vec3(position_1_x,position_1_y,position_1_z),position_1_show,position_1_exit)
                
                local position_2_name = "Location 2" --export: Position 2 Name
                local position_2_show = false --export: Position 2 show in the list
                local position_1_exit = false --export: Position 2 exit when arrived
                local position_2_x = -54538 -- Initial World Position
                local position_2_y = 83048 -- Initial World Position
                local position_2_z = -46242 -- Initial World Position
                addPosition(position_2_name,vec3(position_2_x,position_2_y,position_2_z),position_2_show,position_2_exit)
                
                local position_3_name = "Location 3" --export: Position 3 Name
                local position_3_show = true --export: Position 3 show in the list
                local position_1_exit = true --export: Position 3 exit when arrived
                local position_3_x = -54541 -- Initial World Position
                local position_3_y = 83051 -- Initial World Position
                local position_3_z = -46292 -- Initial World Position
                addPosition(position_3_name,vec3(position_3_x,position_3_y,position_3_z),position_3_show,position_3_exit)
                
                local position_4_name = "Location 4" --export: Position 4 Name
                local position_4_show = false --export: Position 4 show in the list
                local position_1_exit = false --export: Position 4 exit when arrived
                local position_4_x = -109616 -- Initial World Position
                local position_4_y = 166671 -- Initial World Position
                local position_4_z = 34342 -- Initial World Position
                addPosition(position_4_name,vec3(position_4_x,position_4_y,position_4_z),position_4_show,position_4_exit)
                
                local position_5_name = "Location 5" --export: Position 5 Name
                local position_5_show = true --export: Position 5 show in the list
                local position_1_exit = true --export: Position 5 exit when arrived
                local position_5_x = -109624.8 -- Initial World Position
                local position_5_y = 166690 -- Initial World Position
                local position_5_z = 34302 -- Initial World Position
                addPosition(position_5_name,vec3(position_5_x,position_5_y,position_5_z),position_5_show,position_5_exit)

                -- matrix of routs between positions
                routes = {{}, {}, {}, {}, {}}
                
                routes[1][1] = 1
                routes[1][2] = 2
                routes[1][3] = 2
                routes[1][4] = 4
                routes[1][5] = 4
                
                routes[2][1] = 1
                routes[2][2] = 2
                routes[2][3] = 3
                routes[2][4] = 4
                routes[2][5] = 4
                
                routes[3][1] = 2
                routes[3][2] = 2
                routes[3][3] = 3
                routes[3][4] = 2
                routes[3][5] = 2
                
                routes[4][1] = 1
                routes[4][2] = 2
                routes[4][3] = 2
                routes[4][4] = 4
                routes[4][5] = 5
                
                routes[5][1] = 4
                routes[5][2] = 4
                routes[5][3] = 4
                routes[5][4] = 4
                routes[5][5] = 5
                -- end of matrix of routs
                
                local defaultOrientation = 180 --export: forward orientation of degrees
                maxAngularVelocity = 0.5 --export: maximum alowed angular velocity
                angularVelocityThreshold = 0.01 --export: criteria for stabilization
                angleThreshold = 0.5  --export: minimum allowed deviation
                maxVelocityAtmo = 1500 --export: max velocity 'km/h'
                maxVelocitySpace = 7000 --export: max velocity 'km/h'
                spaceToAtmoAltitude = 7200 --export: altitude in 'm' to switch the speed
                yawRotationInput = 0 --export: set yaw rotation speed is required
                verticalSafeDistanceFromStart = 0.1 --export: how far from initial position start horizontal movement in 'm'
                positionThreshold = 3 --export: maximum allowed deviation from destinationin in 'm'
                accelerationHorizontalFactor = 1 --export: horizontal acceleration factor
                accelerationVerticalFactor = 1 --export: vertical acceleration factor
                --useAntigravOnly = false --export: use space engines of not
                exitWhenArrived = true --export: exit from control if possible
                
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                torqueFactor = 2 --export: Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                function recordToDatabank()
                    --system.print("RECODT TO DATABANK")
                    local shipInfo = {
                            positionShow = positionShow,
                            positionExit = positionExit,
                            positionNames = positionNames,
                            maxAngularVelocity = maxAngularVelocity,
                            angularVelocityThreshold = angularVelocityThreshold,
                            angleThreshold = angleThreshold,
                            maxVelocityAtmo = maxVelocityAtmo,
                            maxVelocitySpace = maxVelocitySpace,
                            spaceToAtmoAltitude = spaceToAtmoAltitude,
                            yawRotationInput = yawRotationInput,
                            verticalSafeDistanceFromStart = verticalSafeDistanceFromStart,
                            positionThreshold = positionThreshold,
                            accelerationHorizontalFactor = accelerationHorizontalFactor,
                            accelerationVerticalFactor = accelerationVerticalFactor,
                            pitchSpeedFactor = pitchSpeedFactor,
                            yawSpeedFactor = yawSpeedFactor,
                            rollSpeedFactor = rollSpeedFactor,
                            brakeSpeedFactor = brakeSpeedFactor,
                            brakeFlatFactor = brakeFlatFactor,
                            autoRoll = autoRoll,
                            autoRollFactor = autoRollFactor,
                            turnAssist = turnAssist,
                            turnAssistFactor = turnAssistFactor,
                            torqueFactor = torqueFactor,
                            exitWhenArrived = exitWhenArrived
                        }
                    local jsonString = json.encode(shipInfo)
                    databank_1.setStringValue("shipInfo",jsonString)
                    local dataString = databank_1.getStringValue("shipPositions")
                    if dataString == "" or recordModeIsActive then 
                        databank_1.setStringValue("shipPositions",json.encode(positions))
                    end
                end

                if useDatabank and databank_1 then
                    --system.print("USE DATABANK")
                    if updateDatabank then
                        recordToDatabank()
                    else
                        local dataString1 = databank_1.getStringValue("shipInfo")
                        local dataString2 = databank_1.getStringValue("shipPositions")
                        if dataString1 ~= "" and dataString2 ~= "" then
                            --system.print("shipInfo = "..dataString)
                            local shipInfo = json.decode(dataString1)
                            local shipPositions = json.decode(dataString2)
                            
                            positions = shipPositions or positions
                            positionShow = shipInfo.positionShow or positionShow
                            positionExit = shipInfo.positionExit or positionExit
                            positionNames = shipInfo.positionNames or positionNames
                            angularVelocityThreshold = shipInfo.angularVelocityThreshold or angularVelocityThreshold
                            maxAngularVelocity = shipInfo.maxAngularVelocity or maxAngularVelocity
                            angleThreshold = shipInfo.angleThreshold or angleThreshold
                            maxVelocityAtmo = shipInfo.maxVelocityAtmo or maxVelocityAtmo
                            maxVelocitySpace = shipInfo.maxVelocitySpace or maxVelocitySpace
                            spaceToAtmoAltitude = shipInfo.spaceToAtmoAltitude or spaceToAtmoAltitude
                            yawRotationInput = shipInfo.yawRotationInput or yawRotationInput
                            verticalSafeDistanceFromStart = shipInfo.verticalSafeDistanceFromStart or verticalSafeDistanceFromStart
                            positionThreshold = shipInfo.positionThreshold or positionThreshold
                            accelerationHorizontalFactor = shipInfo.accelerationHorizontalFactor or accelerationHorizontalFactor
                            accelerationVerticalFactor = shipInfo.accelerationVerticalFactor or accelerationVerticalFactor
                            pitchSpeedFactor = shipInfo.pitchSpeedFactor or pitchSpeedFactor
                            yawSpeedFactor = shipInfo.yawSpeedFactor or yawSpeedFactor
                            rollSpeedFactor = shipInfo.rollSpeedFactor or rollSpeedFactor
                            brakeSpeedFactor = shipInfo.brakeSpeedFactor or brakeSpeedFactor
                            brakeFlatFactor = shipInfo.brakeFlatFactor or brakeFlatFactor
                            autoRoll = shipInfo.autoRoll or autoRoll
                            autoRollFactor = shipInfo.autoRollFactor or autoRollFactor
                            turnAssist = shipInfo.turnAssist or turnAssist
                            turnAssistFactor = shipInfo.turnAssistFactor or turnAssistFactor
                            torqueFactor = shipInfo.torqueFactor or torqueFactor
                            exitWhenArrived = shipInfo.exitWhenArrived or exitWhenArrived
                        else
                            recordToDatabank()
                        end
                    end
                end

                local orientationAngleRad = defaultOrientation * math.pi / 180
                forwardOrientation = vec3({0,math.sin(orientationAngleRad),math.cos(orientationAngleRad)})
                startVertical = vec3(core.getConstructWorldOrientationUp())
                changingPositions = false
                stabilizationIsActive = true
                elevatorModeIsActive = false
                recordModeIsActive = false
                startPosition = vec3(core.getConstructWorldPos())

                function getNearestPosition(position, positions)
                    local prevDistance = 999999999
                    local positionIndex = 1
                    for k,v in pairs(positions) do
                        local distance = (position - v):len()
                        --system.print("distance to '"..positionNames[k] .."' = "..distance)
                        if distance < prevDistance then
                            prevDistance = distance
                            positionIndex = k
                        end
                    end
                    return positionIndex
                end
                

                initialPositionIndex = getNearestPosition(startPosition, positions)
                currentPositionIndex = initialPositionIndex
                currentDestinationIndex = initialPositionIndex
                displayIndex = initialPositionIndex

                system.print("Initial position '"..positionNames[initialPositionIndex] .."'")
                currentPositionIndex = initialPositionIndex

                
                --[[function setControlMasterMode(controlMasterMode)
                    if unit.getControlMasterModeId() ~= controlMasterMode then
                        unit.cancelCurrentControlMasterMode()
                        Nav.axisCommandManager:setMasterMode(controlMasterMode)
                    end
                end--]]
                
                --setControlMasterMode(controlMasterModeId.cruise)

                function nextDestination()
                    if currentDestinationIndex < #positions then
                        currentDestinationIndex = currentDestinationIndex + 1
                        if positionShow[currentDestinationIndex + 1] then
                            changingPositions = true
                            if gearExtended then
                                Nav.control.retractLandingGears()
                            end
                        else
                            changingPositions = false
                            nextDestination()
                        end
                    end
                end

                function prevDestination()
                    if currentDestinationIndex > 1 then
                        currentDestinationIndex = currentDestinationIndex - 1
                        if positionShow[currentDestinationIndex - 1] then
                            changingPositions = true
                            if gearExtended then
                                Nav.control.retractLandingGears()
                            end
                        else
                            changingPositions = false
                            prevDestination()
                        end
                    end
                end
                
                function nextPosition()
                    local nextPositionIndex = routes[currentPositionIndex][currentDestinationIndex]

                    if nextPositionIndex and currentPositionIndex ~= nextPositionIndex then
                        system.print("Fly to '".. positionNames[nextPositionIndex] .."'")
                        currentPositionIndex = nextPositionIndex
                        changingPositions = true
                        if gearExtended then
                            Nav.control.retractLandingGears()
                        end
                    end
                end

                
                function executeDisplayPosition()
                    currentDestinationIndex = displayIndex
                    changingPositions = true
                    if gearExtended then
                        Nav.control.retractLandingGears()
                    end
                end
                
                function getDistanceDisplayString(distance)
                    if distance > 100000 then
                        -- Convert to SU
                        return utils.round(distance/1000/200,1) .. " SU"
                    elseif distance < 1000 then
                        return utils.round(distance,1) .. " M"
                    else
                        -- Convert to KM
                        return utils.round(distance/1000,1) .. " KM"
                    end
                end

                --[[local altitude = core.getAltitude()
                if antigrav and altitude >= 1000 and altitude < 200000 and antigrav.getState() == 0 then
                    antigrav.activate()
                    antigrav.setBaseAltitude(math.floor(altitude+1))
                end--]]

                
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

    screen_1:
        mouseDown(x,y):
            lua: |
                local convertedX = x * 1024
                local convertedY = y * 612
                local ButtonPadding = 4
                local ButtonX = ButtonPadding
                local ButtonY = 105
                local ButtonWidth = 1024 - ButtonPadding
                local ButtonHeight = 35
                
                for k,v in pairs(positions) do
                    local buttonX = ButtonX
                    local buttonY = ButtonY + (#positions-k)*(ButtonHeight+ButtonPadding)
                    
                    local selected = (k == currentDestinationIndex)
                    if not selected then
                        if convertedX > buttonX and convertedX < buttonX + ButtonWidth and convertedY > buttonY and convertedY < buttonY + ButtonHeight then
                            displayIndex = k
                        end
                    end
                end
                
                if convertedY < 95 and currentDestinationIndex ~= displayIndex then
                    executeDisplayPosition()
                end


    system:
        flush:
            lua: |
                --system.print(antigrav.getBaseAltitude())

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput
                
                local targetAngularVelocity = vec3()

                -- Axis    
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                if worldVertical:len() < 0.1 then
                    worldVertical = startVertical -- Use our stored one if in space
                end

                local constructUp = vec3(core.getConstructWorldOrientationUp())
                --local constructUp = vec3(core.getConstructWorldOrientationForward())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                --local constructForward = -vec3(core.getConstructWorldOrientationUp())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldAbsoluteVelocity())
                local constructVelocityDir = vec3(constructVelocity:normalize())
                
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())

                -- STABILIZATION CODE
                if stabilizationIsActive then
                
                    if constructAngularVelocity:len() > maxAngularVelocity then
                        constructSomersault = true
                    elseif constructAngularVelocity:len() < angularVelocityThreshold then
                        constructSomersault = false
                    end

                    if not constructSomersault then
                        
                        local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                        local currentPitchDeg = angle_between(worldVertical,constructForward) * constants.rad2deg - 90
                        local currentYawDeg = getRoll(forwardOrientation, constructUp, constructRight)

                        local constructForwardHorizontal = constructForward:project_on_plane(-worldVertical)
                        local constructRightHorizontal = constructRight:project_on_plane(-worldVertical)

                        local desiredPitchDeg = 0
                        local desiredRollDeg = 0
                        local desiredYawDeg = 0

                        local function stabilizeAxis(deviationDeg, threshold, stabPID)
                            local deviationDeg = deviationDeg
                            if deviationDeg > 180 then
                                deviationDeg = deviationDeg - 360
                            elseif deviationDeg < -180 then
                                deviationDeg = deviationDeg + 360
                            end

                            if math.abs(deviationDeg) > threshold then
                                stabPID:inject(-deviationDeg)
                                return stabPID:get()
                            end
                            return 0
                        end
                        
                        local rollInput = stabilizeAxis(currentRollDeg - desiredRollDeg,angleThreshold,rollPID)
                        local pitchInput = stabilizeAxis(currentPitchDeg - desiredPitchDeg,angleThreshold,pitchPID)
                        local yawInput = finalYawInput
                        
                        if elevatorModeIsActive then
                            if yawRotationInput == 0 then
                                yawInput = stabilizeAxis(currentYawDeg - desiredYawDeg,angleThreshold,yawPID)
                            else
                                yawInput = yawRotationInput
                            end
                        end

                        targetAngularVelocity = targetAngularVelocity + pitchInput * pitchSpeedFactor * constructRightHorizontal + rollInput * rollSpeedFactor * constructForwardHorizontal + yawInput * yawSpeedFactor * -worldVertical

                        if targetAngularVelocity:len() > maxAngularVelocity then
                            targetAngularVelocity = targetAngularVelocity:normalize() * maxAngularVelocity * 0.95
                        end
                    end
                end
                -- END STABILIZATION CODE

                local constructStabilized = false
                if (yawRotationInput == 0 and constructAngularVelocity:len() < angularVelocityThreshold and targetAngularVelocity:len() < angularVelocityThreshold)
                        or (yawRotationInput ~= 0 and math.abs(constructAngularVelocity:dot(constructRight)) < angularVelocityThreshold and math.abs(constructAngularVelocity:dot(constructForward)) < angularVelocityThreshold and targetAngularVelocity:len() < angularVelocityThreshold + yawSpeedFactor * math.abs(yawRotationInput))
                        then
                    constructStabilized = true
                    --system.print("construct stabilized")
                else
                    --system.print("construct not stabilized")
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                if elevatorModeIsActive then
                    --system.print("currentPositionIndex = "..currentPositionIndex)
                    local position = positions[currentPositionIndex]
                    --system.print("currentPositionIndex = '"..currentPositionIndex .."'")
                    --system.print("position = '"..position.x .."' '"..position.y .."' '"..position.z .."'")
                    local constructPosition = vec3(core.getConstructWorldPos())
                    --system.print("constructPosition = "..constructPosition.x .." "..constructPosition.y .." "..constructPosition.z)
                    local distanceToPositionVect = position and (position - constructPosition) or vec3(positionThreshold+1,0,0)

                    local altitude = core.getAltitude()

                    --distanceToPos = constructPosition:dist(position)
                    distanceToPos = distanceToPositionVect:len()
                    
                    local verticalStrafeEngineTags = 'thrust analog vertical'
                    local lateralStrafeEngineTags = 'thrust analog lateral'
                    local longitudinalEngineTags = 'thrust analog longitudinal'
                    local priority1 = ''
                    local priority2 = ''
                    local priority3 = ''
                    local useBrake = false
                    local useForceBrake = false
                    
                    local totalEngineTags =  lateralStrafeEngineTags.. ' , ' .. longitudinalEngineTags.. ' , ' .. verticalStrafeEngineTags
                    
                    local gravity = core.g() * worldVertical:normalize()
                    local requiredAcceleration = -gravity
                    --system.print("distanceToPos = "..distanceToPos.." "..positionThreshold)
                    --system.print("distanceToPos = "..(position - constructPosition):len().." "..positionThreshold)
                    if distanceToPos < positionThreshold then
                        --system.print("Position '".. positionNames[currentPositionIndex] .."' reached")
                        changingPositions = false
                        nextPosition()
                        if not changingPositions then
                            if not gearExtended then
                                Nav.control.extendLandingGears()
                                gearExtended = true
                            end
                            
                            if exitWhenArrived and initialPositionIndex ~= currentDestinationIndex then --and Nav.control.isAnyLandingGearExtended() == 1 then
                                if positionExit[currentPositionIndex] then
                                    unit.exit()
                                end
                            end
                            
                            if constructStabilized then
                                useForceBrake = true
                            else
                                useBrake = true
                            end
                            priority1 = 'brake'
                            totalEngineTags = totalEngineTags..', brake'
                            startPosition = position

                            --[[if antigrav then
                                if altitude >=900 and altitude < 200000 then
                                    if antigrav.getState() == 0 then
                                        antigrav.activate()
                                        system.print("ANTIGRAV ACTIVATED")
                                    end
                                    --if math.abs(antigrav.getBaseAltitude() - altitude) > 3 then
                                    --    antigrav.setBaseAltitude(math.floor(altitude))
                                    --end
                                    requiredAcceleration = vec3()
                                else
                                    if antigrav.getState() == 1 then
                                        antigrav.deactivate()
                                        system.print("ANTIGRAV DEACTIVATED")
                                    end
                                end
                            end--]]
                        end

                    elseif constructStabilized and position then
                        --system.print("Fly to '".. positionNames[currentPositionIndex] .."'")
                        changingPositions = true
                        
                        local constructMass = core.getConstructMass()
                        
                        local newMaxBrake = json.decode(unit.getData()).maxBrake
                        if newMaxBrake ~= nil then
                            maxBrake = newMaxBrake
                        end
                        
                        local maxBrakeAcceleration = maxBrake and maxBrake / constructMass or 0

                        local constructVelocityUp = constructVelocity:dot(constructUp)
                        local constructVelocityRight = constructVelocity:dot(constructRight)
                        local constructVelocityForward = constructVelocity:dot(constructForward)
                        
                        local gravityUp = gravity:dot(constructUp)
                        local gravityRight = gravity:dot(constructRight)
                        local gravityForward = gravity:dot(constructForward)
                        
                        local constructUpRelative = core.getConstructOrientationUp()
                        --local constructUpRelative = core.getConstructOrientationForward()
                        local constructForwardRelative = core.getConstructOrientationForward()
                        --local constructForwardRelative = -core.getConstructOrientationUp()
                        local constructRightRelative = core.getConstructOrientationRight()
                        
                        local atmoDencity = unit.getAtmosphereDensity()
                        
                        local function getMaxThrust(dencity, direction)
                            local kinematic = core.getMaxKinematicsParametersAlongAxis('all', direction)
                            
                            local thrustPos = dencity * kinematic[1]
                            local thrustNeg = dencity * kinematic[2]
                            if dencity < 0.1 then
                                thrustPos = thrustPos + (1 - 10 * dencity) * kinematic[3]
                                thrustNeg = thrustNeg + (1 - 10 * dencity) * kinematic[4]
                            end
                            return thrustPos, thrustNeg
                        end
                        
                        local maxThrustUp, maxThrustDown = getMaxThrust(atmoDencity, constructUpRelative)
                        local maxAccelerationUp = maxThrustUp / constructMass  + gravityUp + maxBrakeAcceleration
                        local maxAccelerationDown = -maxThrustDown / constructMass - gravityUp - maxBrakeAcceleration
                        --system.print("brake="..maxBrakeAcceleration.." accelDown="..maxAccelerationDown.." accelUp="..maxAccelerationUp)
                        local maxThrustRight, maxThrustLeft = getMaxThrust(atmoDencity, constructRightRelative)
                        local maxAccelerationRight = maxThrustRight / constructMass + gravityRight
                        local maxAccelerationLeft = -maxThrustLeft / constructMass - gravityRight

                        local maxThrustForward, maxThrustBack = getMaxThrust(atmoDencity, constructForwardRelative)
                        local maxAccelerationForward = maxThrustForward / constructMass + gravityForward
                        local maxAccelerationBack = -maxThrustBack / constructMass - gravityForward
                        --system.print("atmo="..kinematicUp[1].." space="..kinematicUp[3])

                        local distanceUp = distanceToPositionVect:dot(constructUp)
                        local distanceRight = distanceToPositionVect:dot(constructRight)
                        local distanceForward = distanceToPositionVect:dot(constructForward)
                        
                        if math.abs(distanceRight/distanceUp) < 0.001 then
                            distanceRight = 0
                        end
                        
                        if math.abs(distanceForward/distanceUp) < 0.001 then
                            distanceForward = 0
                        end

                        local verticalDitanceFromStart = math.abs((constructPosition - startPosition):dot(worldVertical))
                        --system.print(verticalDitanceFromStart)
                        
                        --to avoid damage if something is around the starting position
                        local horizontalMovementAllowed = verticalDitanceFromStart > verticalSafeDistanceFromStart
                        --to avoid falling down if horizontal movement is significant
                        local verticalMovementAllowed = distanceUp > 0 or math.abs(distanceUp) > 5 * math.max(math.abs(distanceRight),math.abs(distanceForward))

                        if not horizontalMovementAllowed then--hold starting horizontal position
                            --system.print("not horizontalMovementAllowed")
                            distanceRight = (vec3(startPosition - constructPosition)):dot(constructRight)
                            distanceForward = (vec3(startPosition - constructPosition)):dot(constructForward)
                        end
    
                        if not verticalMovementAllowed then
                            --system.print("not verticalMovementAllowed " .. distanceUp)
                            if horizontalMovementAllowed then--move in horizontal
                                distanceUp = 0
                            else--try to rise up to the safe limit
                                distanceUp = 1 + verticalSafeDistanceFromStart - verticalDitanceFromStart
                            end
                        end

                        local function getVelocity(distance, maxAccelerationPos, maxAccelerationNeg)
                            local acceleration = maxAccelerationPos
                            if distance > 0 then
                                acceleration = maxAccelerationNeg
                            end
                            return utils.sign(distance) * math.sqrt(math.abs(distance * 2 * acceleration)) / 2 -- has taken 2 time less (temporary)
                        end

                        local requiredVelocityUp = getVelocity(distanceUp,maxAccelerationUp,maxAccelerationDown)
                        local requiredVelocityRight = getVelocity(distanceRight,maxAccelerationRight,maxAccelerationLeft)
                        local requiredVelocityForward = getVelocity(distanceForward,maxAccelerationForward,maxAccelerationBack)

                        local requiredVelocity = requiredVelocityUp*constructUp + requiredVelocityRight*constructRight + requiredVelocityForward*constructForward

                        --system.print(" Altitude="..math.floor(altitude))
                        if altitude == 0 --in deep space
                            or altitude > spaceToAtmoAltitude --above the braking limit from space to atmo velocity
                            or (requiredVelocityUp > 0 and atmoDencity < 0.1) --moving up in the rarefied atmosphere
                            then
                            if requiredVelocity:len() > maxVelocitySpace / 3.6 then --requred velocity is more than max in space
                                requiredVelocity = maxVelocitySpace / 3.6 * requiredVelocity:normalize()
                            end
                        elseif requiredVelocity:len() > maxVelocityAtmo / 3.6 then -- limit velocity by max in atmo
                            requiredVelocity = maxVelocityAtmo / 3.6 * requiredVelocity:normalize()
                        end
                        ---[[
                        if (distanceToPos < 500 and requiredVelocity:len() > distanceToPos / 3.6) then -- limit velocity if it's close to destination
                            --system.print("Limit velocity by "..math.floor(distanceToPos).."km/h")
                            requiredVelocity = distanceToPos / 3.6 * requiredVelocity:normalize()
                        end --]]

                        ---[[
                        if (requiredVelocity:len() < 5 / 3.6) then -- min velocity to reach destination
                            requiredVelocity = 5 / 3.6 * requiredVelocity:normalize()
                        end --]]
                        
                        local deltaVelocity = requiredVelocity - constructVelocity
                        
                        local deltaVelocityForward = deltaVelocity:dot(constructForward)
                        local deltaVelocityRight = deltaVelocity:dot(constructRight)
                        local deltaVelocityUp = deltaVelocity:dot(constructUp)
                        
                        local function getAccelerationK(delta)
                            local k = math.abs(delta)
                            if k > 1 then
                                k = k^2
                            end
                            return k
                        end
                        
                        local kForward = getAccelerationK(deltaVelocityForward) -- if delta is significant, increase acceleration
                        local kRight = getAccelerationK(deltaVelocityRight)
                        local kUp = getAccelerationK(deltaVelocityUp)

                        local accelerationForward = deltaVelocityForward * kForward * constructForward * accelerationHorizontalFactor
                        local accelerationRight = deltaVelocityRight * kRight * constructRight* accelerationHorizontalFactor
                        local accelerationUp = deltaVelocityUp * kUp * constructUp * accelerationVerticalFactor

                        ---[[ to avoid falling down due to engine warmup
                        if distanceToPos < 100 --costruct close to position
                            and (atmoDencity > 0.1 or altitude < 1000 and altitude ~=0) --on planet
                            and deltaVelocityUp * kUp < 0.99 * gravityUp --significant acceleration down required (gravity will be compensated below)
                            then
                            --system.print("acceleration down limited "..math.floor(deltaVelocityUp * kUp))
                            accelerationUp = 0.99 * gravityUp --to get final acceleration less than gravity to leave the engine working
                        else
                            --system.print("acceleration down NOT limited ")
                        end --]]

                        --system.print("dv=" .. math.floor(deltaVelocityUp*100)/100 .. " a=" .. math.floor(accelerationUp:len()*100)/100)
                        --[[
                        if requiredVelocityUp > -10 -- need to go up
                            and antigrav --antigrav equipped
                            then
                            if altitude >= 900 and altitude < 200000 and constructVelocityUp < 100 then
                                if antigrav.getState() == 0 then
                                    antigrav.activate()
                                    system.print("ANTIGRAV ACTIVATED")
                                end
                                --antigrav.setBaseAltitude(math.floor(altitude+requiredVelocityUp))
                                --system.print("base="..math.floor(antigrav.getBaseAltitude()).." set="..math.floor(altitude+100))
                                --if atmoDencity < 0.02 or useAntigravOnly then
                                    requiredAcceleration = accelerationForward + accelerationRight
                                --else
                                --    requiredAcceleration = requiredAcceleration + accelerationUp + accelerationForward + accelerationRight
                                --end
                            else
                                if antigrav.getState() == 1 then
                                    antigrav.deactivate()
                                    system.print("ANTIGRAV DEACTIVATED")
                                end
                                requiredAcceleration = requiredAcceleration + accelerationUp + accelerationForward + accelerationRight
                            end
                        else
                            if antigrav and antigrav.getState() == 1 then
                                antigrav.deactivate()
                                system.print("ANTIGRAV DEACTIVATED")
                            end
                            requiredAcceleration = requiredAcceleration + accelerationUp + accelerationForward + accelerationRight
                        end--]]
                        requiredAcceleration = requiredAcceleration + accelerationUp + accelerationForward + accelerationRight
                        --[[
                        system.print(" maxAcc="..math.floor(maxAccelerationUp*100)/100
                            .." distUp="..math.floor(distanceUp*100)/100
                            .." velUp="..math.floor(requiredVelocityUp*100)/100
                            .." dvelUp="..math.floor(deltaVelocityUp*100)/100
                            .." accUp="..math.floor(accelerationUp:len()*100)/100
                            )--]]

                        
                        if (constructVelocityUp < -1 and deltaVelocityUp > 0)
                            or (constructVelocityUp > 10 and deltaVelocityUp < -10)
                            then
                            -- use brake if required velocity less than actual
                            --system.print("use breake ")
                            useBrake = true
                            priority1 = 'brake'
                            totalEngineTags = totalEngineTags..', brake'
                        end
                        
                        -- if construct velocity direction is not collinear with required velocity direction
                        if math.abs(constructVelocityUp) > 10 and utils.sign(constructVelocityUp) == -utils.sign(requiredVelocityUp) then
                            --system.print(utils.sign(constructVelocityUp).." "..utils.sign(requiredVelocityUp))
                            useForceBrake = true
                        end
                        
                    else -- should fly but not stabilized yet or no assigned position
                        changingPositions = false
                        useBrake = true
                        --useForceBrake = true
                        priority1 = 'brake'
                        totalEngineTags = totalEngineTags..', brake'
                        --[[if antigrav then
                            if altitude >=1000 and altitude < 200000 then
                                if antigrav.getState() == 0 then
                                    antigrav.activate()
                                    system.print("ANTIGRAV ACTIVATED")
                                end
                                --if math.abs(antigrav.getBaseAltitude() - altitude) > 3 then
                                --    antigrav.setBaseAltitude(math.floor(altitude))
                                --end
                                requiredAcceleration = vec3()
                            else
                                if antigrav.getState() == 1 then
                                    antigrav.deactivate()
                                    system.print("ANTIGRAV DEACTIVATED")
                                end
                            end
                        end--]]

                    end
                    
                    if not useBrake and not useForceBrake then -- reset brake
                        Nav:setEngineForceCommand('brake', vec3())
                    end

                    Nav:setEngineForceCommand(totalEngineTags, requiredAcceleration, dontKeepCollinearity, priority1, priority2, priority3, tolerancePercentToSkipOtherPriorities)

                    if useForceBrake then
                        Nav:setEngineForceCommand('brake', -constructVelocityDir*1000000)
                    end
                else --elevator mode is off
                    distanceToPos = 1
                    changingPositions = false
                end
                
                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 and not elevatorModeIsActive and not stabilizationIsActive then
                    local autoRollRollThreshold = 1.0
                    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                    local currentRollDegAbs = math.abs(currentRollDeg)
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if not elevatorModeIsActive and not stabilizationIsActive and autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if not elevatorModeIsActive and not stabilizationIsActive and turnAssist and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio
                    
                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio
                    
                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end
                    
                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)
                    
                
                if not elevatorModeIsActive then
                    -- Brakes
                    local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                    Nav:setEngineForceCommand('brake', brakeAcceleration)
                    -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                    local autoNavigationEngineTags = ''
                    local autoNavigationAcceleration = vec3()
                    local autoNavigationUseBrake = false
                    
                    -- Longitudinal Translation
                    local longitudinalEngineTags = 'thrust analog longitudinal'
                    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                    if (longitudinalCommandType == axisCommandType.byThrottle) then
                        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                        Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                    elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                        if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                            Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                        then
                            autoNavigationUseBrake = true
                        end
                    
                    end
                    
                    -- Lateral Translation
                    local lateralStrafeEngineTags = 'thrust analog lateral'
                    local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                    if (lateralCommandType == axisCommandType.byThrottle) then
                        local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                        Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                    elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                        local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                    end
                    
                    -- Vertical Translation
                    local verticalStrafeEngineTags = 'thrust analog vertical'
                    local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                    if (verticalCommandType == axisCommandType.byThrottle) then
                        local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                        Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                    elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                        local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                    end
                    
                    -- Auto Navigation (Cruise Control)
                    if (autoNavigationAcceleration:len() > constants.epsilon) then
                        if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                        then
                            --system.print("auto brake ".. autoNavigationAcceleration:len())
                            autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                        end
                        Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                    end
                    
                    -- Rockets
                    Nav:setBoosterCommand('rocket_engine')
                end

        update:
            lua: |
                Nav:update()
                local content = "<svg width='100%' height='100%' style='position:absolute;top:0;left:0'  viewBox='0 0 1920 1080'>"
                if screen_1 then
                    content = "<svg class='bootstrap' viewBox='0 0 1024 612'>"
                    content = content .. "<path d='M 0 0 L 194 75 Q 512 95 830 75 L 1024 0' style='stroke:black;opacity:1;stroke-width:3;fill-opacity:0.9;fill:rgb(55,55,55)'/>"
                else
                    content = content .. "<path d='M 700 0 L 740 75 Q 960 95 1180 75 L 1220 0' style='stroke:black;opacity:1;stroke-width:3;fill-opacity:0.9;fill:rgb(55,55,55)'/>"
                end
                local font = "Bank"
                if screen_1 then
                    font = "Calibri"
                end
                content = content .. "<text x='50%' y='20px' style='font-size:22px;fill:white;text-anchor:middle;font-family:" .. font .. "'>Atmo Elevator Control</text>"
                local floorString = positionNames[currentDestinationIndex] or "unknown"
                local displayString = positionNames[displayIndex] or "unknown"
                if currentDestinationIndex == 1 then
                    floorString = floorString .. " (Ground)"
                elseif currentDestinationIndex == #positions then
                    floorString = floorString .. " (Top)"
                end
                if displayIndex == 1 then
                    displayString = displayString .. " (Ground)"
                elseif currentDestinationIndex == #positions then
                    displayString = displayString .. " (Top)"
                end
                
                if not changingPositions then
                    content = content .. "<text x='50%' y='35px' style='font-size:18px;fill:lightgray;text-anchor:middle;font-family:" .. font .. "'>Current Level: " .. floorString .. "</text>"
                    if button_3 then
                        if displayIndex ~= currentDestinationIndex then
                            content = content .. "<text x='50%' y='48px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Press To Move To: " .. displayString .. "</text>"
                        else
                            content = content .. "<text x='50%' y='48px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Use Buttons to Select Floor</text>"
                        end
                    end
                else
                    content = content .. "<text x='50%' y='35px' style='font-size:18px;fill:KHAKI;text-anchor:middle;font-family:" .. font .. "'>Moving To: " .. floorString .. "</text>"
                    content = content .. "<text x='50%' y='48px' style='font-size:16px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Distance: " .. getDistanceDisplayString(distanceToPos) .. "</text>"
                end
                --if unit.getElementClass() == "ECU" then
                --    content = content .. "<text x='50%' y='60px' style='font-size:18px;fill:darkred;text-anchor:middle;font-family:" .. font .. "'>Activate Controller To Use</text>"
                --else
                    local y = 60
                    if not screen_1 then
                        if button_3 then
                            if displayIndex ~= currentDestinationIndex then
                                if displayIndex < #positions then
                                    content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Above - " .. positionNames[displayIndex+1] .. "</text>"
                                    y = y + 15
                                end
                                if displayIndex > 1 then
                                    content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Below - " .. positionNames[displayIndex-1] .. "</text>"
                                end
                            end
                        else
                            if currentDestinationIndex < #positions then
                                content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Up - " .. positionNames[currentDestinationIndex+1] .. "</text>"
                                y = y + 15
                            end
                            if currentDestinationIndex > 1 then
                                content = content .. "<text x='50%' y='" .. y .. "' style='font-size:16px;fill:LAVENDER;text-anchor:middle;font-family:" .. font .. "'>Down - " .. positionNames[currentDestinationIndex-1] .. "</text>"
                            end
                        end
                    else
                        y = y + 10
                        if currentDestinationIndex ~= displayIndex then
                            content = content .. "<text x='50%' y='" .. y .. "' style='font-size:28px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Confirm Destination: " .. positionNames[displayIndex] .. "</text>"
                        else
                            content = content .. "<text x='50%' y='" .. y .. "' style='font-size:28px;fill:orange;text-anchor:middle;font-family:" .. font .. "'>Select a Destination</text>"
                        end
                    end
                --end
                if screen_1 then
                    -- Add buttons for the floors
                    local ButtonPadding = 4
                    local ButtonX = ButtonPadding
                    local ButtonY = 105
                    local ButtonWidth = 1024 - ButtonPadding
                    local ButtonHeight = 35
                    local defaultFill = "rgb(39,89,87)"
                    local selectedFill = "rgb(200,200,200)"
                    local defaultFontColor = "white"
                    local selectedFontColor = "black"
                    local displayFill = "orange"
                    
                    for k,v in pairs(positions) do
                        local buttonX = ButtonX
                        local buttonY = ButtonY + (#positions-k)*(ButtonHeight+ButtonPadding)
                        
                        local selected = (k == currentDestinationIndex)
                        local selectedDisplay = (k == displayIndex)
                        
                        -- Draw a rectangle for the 'button'
                        content = content .. '<rect width="' .. ButtonWidth .. '" height="' .. ButtonHeight .. '" x="' .. buttonX .. '" y="' .. buttonY .. '" style="fill:'
                        if selected then
                            content = content .. selectedFill
                        elseif selectedDisplay then
                            content = content .. displayFill
                        else
                            content = content.. defaultFill
                        end
                        content = content .. ';stroke-width:1;stroke:white;" />'
                        -- And draw the text
                        content = content .. "<text x='" .. buttonX + ButtonWidth/2 .. "' y='" .. buttonY + ButtonHeight/2 + 4 .. "' font-size='24px' fill='"
                        if selected or selectedDisplay then
                            content = content .. selectedFontColor
                        else
                            content = content.. defaultFontColor
                        end 
                        content = content .. "' text-anchor='middle' font-family='" .. font .. "'>" .. positionNames[k] .. "</text>"
                    end
                end

                if not screen_1 then
                    if stabilizationIsActive then
                        content = content .. [[
                            <rect x="30" y="30" rx="10" ry="10" width="240" height="30" style="fill:green;stroke:black;stroke-width:3;opacity:0.7" />
                            <text x="40" y="50" fill="white">Stabilization ON (Alt+1)</text>
                            ]]
                    else
                        content = content .. [[
                            <rect x="30" y="30" rx="10" ry="10" width="240" height="30" style="fill:red;stroke:black;stroke-width:3;opacity:0.7" />
                            <text x="40" y="50" fill="white">Stabilization OFF (Alt+1)</text>
                            ]]
                    end
                    
                    if elevatorModeIsActive then
                        content = content .. [[
                            <rect x="30" y="70" rx="10" ry="10" width="240" height="30" style="fill:green;stroke:black;stroke-width:3;opacity:0.7" />
                            <text x="40" y="90" fill="white">Elevator Mode ON (Alt+2)</text>
                        ]]
                    else
                        content = content .. [[
                            <rect x="30" y="70" rx="10" ry="10" width="240" height="30" style="fill:red;stroke:black;stroke-width:3;opacity:0.7" />
                            <text x="40" y="90" fill="white">Elevator Mode OFF (Alt+2)</text>
                        ]]
                    end
                    
                    if recordModeIsActive then
                        content = content .. [[
                            <rect x="30" y="110" rx="10" ry="10" width="240" height="30" style="fill:red;stroke:black;stroke-width:3;opacity:0.7" />
                            <text x="40" y="130" fill="white">Overwrite ']]..positionNames[currentDestinationIndex]..[[' (Alt+9)</text>
                        ]]
                    elseif not elevatorModeIsActive then
                        content = content .. [[
                            <rect x="30" y="110" rx="10" ry="10" width="240" height="30" style="fill:black;stroke:black;stroke-width:3;opacity:0.2" />
                            <text x="40" y="130" fill="white">Overwrite Mode OFF (Alt+9)</text>
                        ]]
                    end
                    
                end
                
                content = content .. "</svg>"
                if not screen_1 then
                    system.showScreen(1)
                    system.setScreen(content)
                else
                    screen_1.setHTML(content)
                end

        actionStart:
            args: [option1]
            lua: |
                -- Stabilization
                if not elevatorModeIsActive then
                    if stabilizationIsActive and not elevatorModeIsActive then
                        stabilizationIsActive = false
                        system.print("Stabilization Deactivated")
                    else
                        stabilizationIsActive = true
                        system.print("Stabilization Activated")
                    end
                end

        actionStart:
            args: [option2]
            lua: |
                -- Elevator mode
                if elevatorModeIsActive then
                    elevatorModeIsActive = false
                    Nav:setEngineForceCommand('brake', vec3())
                    system.print("Elevator Deactivated")
                    currentDestinationIndex = getNearestPosition(vec3(core.getConstructWorldPos()), positions)
                else
                    stabilizationIsActive = true
                    elevatorModeIsActive = true
                    recordModeIsActive = false
                    --setControlMasterMode(controlMasterModeId.cruise)
                    system.print("Elevator Activated")
                end
        
        actionStart:
            args: [option9]
            lua: |
                if not elevatorModeIsActive then
                    if recordModeIsActive then
                        -- record current location
                        positions[currentDestinationIndex] = vec3(core.getConstructWorldPos())
                        recordToDatabank()
                        recordModeIsActive = false
                        system.print("New '"..positionNames[currentDestinationIndex].."' recorded")
                    else
                        recordModeIsActive = true
                    end
                end                
                -- Print Current Location To LUA chat
                system.print("Current position: "..tostring(vec3(core.getConstructWorldPos())))

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                if elevatorModeIsActive or recordModeIsActive then
                    nextDestination()
                elseif not upIsActive then
                    upIsActive = true
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
                end
        actionStop:
            args: [up]
            lua: |
                if upIsActive then
                    upIsActive = false
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                end
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                if elevatorModeIsActive or recordModeIsActive then
                    prevDestination()
                elseif not downIsActive then
                    downIsActive = true
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
                end
        actionStop:
            args: [down]
            lua: |
                if downIsActive then
                    downIsActive = false
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                end

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)

        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
